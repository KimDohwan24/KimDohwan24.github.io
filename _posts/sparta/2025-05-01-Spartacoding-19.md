---
layout: post
title: Quick sort, Merge sort, Heap sort
subtitle: 퀵 정렬, 병합 정렬, 힙 정렬
categories: TIL
tags: [TIL]
---

## Quick sort ( 퀵 정렬 )
- 이름 그대로 빠르게 정렬을 수행하는 알고리즘이다.
- 하나의 피벗(pivot)을 기준으로 두 개의 부분리스트로 나누어 하나는 피벗보다 작은 값들의 부분 리스트, 다른 하나는 피벗보다 큰 값들의 부분리스트로 정렬한 다음, 각 부분리스트에 대해 다시 위 처럼 재귀적으로 수행하는 정렬하는 방법이다.
- 비균등 분할 정렬이다 : 항상 데이터를 균등하게 나누지 않는다.
- 불안정 정렬이다 : 피벗을 기준으로 요소들을 `교환(swap)`하면서 정렬을 수행하는데, 이 과정에서 같은 값을 가진 원소들끼리도 위치가 바뀔수 있다.


### Quick 정렬 과정
1. 피벗을 하나 선택한다
2. 피벗을 기준으로 양쪽에서 피버보다 큰 값, 작은값을 찾은 후 왼쪽에서부터 피벗보다 큰 값을 찾고 오른쪽에서부터는 피벗보다 작은 값을 찾는다.
3. 양 방향에서 찾은 두 원소를 교환한다.
4. 왼쪽에서 탐색하는 위치와 오른쪽에서 탐색하는 위치가 엇갈리지 않을 때까지 2번으로 돌아가 위 과정을 반복한다.
5. 엇갈린 기점을 기준으로 두 개의 부분리스트로 나누어 1번으로 돌아가 해당 부분리스트의 길이가 1이 아닐 때까지 1번과정을 반복한다(Divide : 분할)
6. 인접한 부분리스트끼리 합친다. (Conqure : 정복)

### Quick 정렬의 장단점
- 장점 : 속도가 빠르다(평균 속도가 O(NlogN))의 속도를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다
- 단점 : 최악의 경우 시간복잡도는 O(N^2)이다. -> 입력이 이미 정렬되어 있거나, 피벗 선택이 매우 나쁠 경우 시간 복잡도가 `O(N^2)`까지 증가한다. 

### Quick 정렬 예제

```java
public class QuickSortExample {

    // 퀵 정렬 메서드
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // 피벗을 기준으로 배열을 분할
            int pivotIndex = partition(arr, low, high);

            // 분할된 두 부분을 재귀적으로 정렬
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }

    // 분할(partition) 메서드
    public static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];  // 마지막 요소를 피벗으로 선택
        int i = low - 1;        // 작은 요소의 인덱스

        for (int j = low; j < high; j++) {
            // 현재 요소가 피벗보다 작거나 같으면
            if (arr[j] <= pivot) {
                i++;
                // i번째 요소와 j번째 요소 교환
                swap(arr, i, j);
            }
        }

        // 피벗을 올바른 위치로 이동
        swap(arr, i + 1, high);
        return i + 1;
    }

    // 배열 요소를 교환하는 메서드
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // 메인 메서드: 테스트용
    public static void main(String[] args) {
        int[] array = { 10, 7, 8, 9, 1, 5 };
        System.out.println("정렬 전:");
        printArray(array);

        quickSort(array, 0, array.length - 1);

        System.out.println("정렬 후:");
        printArray(array);
    }

    // 배열 출력 메서드
    public static void printArray(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
    }
}
// 정렬 전 : 10 7 8 9 1 5
// 정렬 후 : 1 5 7 8 9 10
```

## Merge sort ( 병합 정렬 )
- 일반적인 방법으로 구현했을때 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다.
- 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법
- 병합 정렬 순서


### Merge sort 정렬 과정
1. 분할(Divide) : 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다
2. 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다
3. 결합(Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다 

```java
1. 분할 ( 반씩 나눔 )
[6, 3, 8, 5, 2, 7, 4, 1]
→ [6, 3, 8, 5]    [2, 7, 4, 1]
→ [6, 3] [8, 5]   [2, 7] [4, 1]
→ [6] [3] [8] [5] [2] [7] [4] [1]

---------------------------------

2. 정복 + 병합 ( 정렬된 채로 병합 )
[6] + [3] → [3, 6]
[8] + [5] → [5, 8]
[2] + [7] → [2, 7]
[4] + [1] → [1, 4]

---------------------------------

-> 다시 병합 :
[3, 6] + [5, 8] → [3, 5, 6, 8]
[2, 7] + [1, 4] → [1, 2, 4, 7]

---------------------------------

-> 최종 병합 :
[3, 5, 6, 8] + [1, 2, 4, 7] → [1, 2, 3, 4, 5, 6, 7, 8]

```

### Merge sort의 장단점
- 단점   

1. 임시 배열 필요 (추가 메모리 사용)
- 병합 정렬은 두 개의 배열(또는 하위 배열)을 합칠 때 임시 배열을 만들어서 데이터를 담아야 합니다.
- 예를 들어 [3, 6] + [5, 8] → [3, 5, 6, 8] 이때 임시 공간 필요
➜ 그래서 배열을 기반으로 하면 **O(n)**의 추가 공간이 필요

2. 제자리 정렬(in-place sorting)이 아님
- 제자리 정렬은 추가 메모리 없이, 주어진 공간에서만 정렬을 수행하는 것을 말한다
- 병합 정렬은 데이터를 병합할 때 다른 메모리 공간에 임시로 복사해야 하므로 엄밀히 말해 제자리 정렬이 아니다.

3. 레코드(데이터)가 클 경우, 이동 비용이 큼
- 배열은 데이터를 직접 이동시켜야 해요.
- 레코드 크기가 크면, 이동에 시간이 많이 소모돼서 비효율적입니다.

- 장점   
1. 항상 안정적인 성능
- 퀵 정렬은 최악의 경우 O(n²)이지만, 병합 정렬은 항상 O(n log n)이다.
- 입력 데이터의 분포(이미 정렬됨, 역순 등)에 영향을 받지 않고 성능이 일정하다.

2. 안정 정렬
- 같은 값을 가진 데이터들의 원래 순서가 유지됨.
- 예: 이름은 같고 나이는 다른 사람들을 이름순 정렬 → 나이순 정렬 시 안정 정렬이 필요함.